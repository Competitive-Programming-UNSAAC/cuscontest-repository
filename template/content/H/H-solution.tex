\vspace*{0cm}
{\Large\textbf{Solución}}

\textbf{Conocimientos requeridos:} Arreglos y prefijos.

Es fácil ver que si el rango a tomar es~$[i, j]$, entonces siempre es óptimo
escoger~$p = \min \{t_i, t_{i + 1}, \dots, t_j\}$, y la solución
será~$p (j - i + 1)$. Si para cada posible rango, se calcula el mínimo en tal rango,
entonces es fácil escoger aquel que maximice esta expresión.

El problema ahora se reduce a calcular el mínimo en un rango, para todos los~$O(n^2)$
rangos. Usar una estructura de datos como un Segment Tree (árbol de segmentos) o BIT
(árbol binario indexado) resultará en un Tiempo Límite Excedido. Ya que se quiere
calcular este mínimo para todos los rangos, es posible reutilizar información. Si se
tiene el mínimo para el rango~$[i, j - 1]$, entonces calcular el mínimo para el
rango~$[i, j]$ en tiempo constante es trivial.

La complejidad por caso de prueba es~$O(n^2)$, dejando una complejidad total
de~$O(tn^2)$.

\textbf{Implementación en C++:}

\begin{lstlisting}[language=C++]
#include <bits/stdc++.h>
using namespace std;

int main(){
  int te; cin >> te;
  while (te--) {
    cin >> n;
    vector<int> a(n);
    for(auto &e: a) cin >> e;
    int gg = 0;
    for (int i = 0; i < n; ++i)
      int mini = a[i];
      for (int j = i; j < n; j++) {
        mini = min(mini, a[j]);
        gg = max(gg, mini * (j - i + 1));
      }
    cout << gg << "\n";
  }
  return 0;
}
\end{lstlisting}

\newpage

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
